include:
  - project: auros/ci-pipeline-includes
    ref: master
    file: Container-Scanning.yml


stages:
  - build
  - authorise
  - audit


# Define an enclaved application. Supported keys:
# `PROCESS_NAME`:    (str) Must match the name of the apps config.json.
# `ENVIRONMENT`:     (str) Either "prod" or "dev".
# `USE_ATTESTATION`: (str, default "true") Determines if secret retrieval requires attestation. You should generally
#                                          not need to define this!
.enclaves: &enclaves
  - PROCESS_NAME: dex_proxy-dexa-main
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-dexa-fuji
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-uni3-goerli-4
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-uni3-goerli-5
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-chainEth-uni3-main-1
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-pdex-main
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-pdex-testnet
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-lyra-testnet
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-lyra-1
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-lyra-2
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-lyra-3
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-lyra-4
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-lyra-5
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-lyra-6
    ENVIRONMENT: prod
  - PROCESS_NAME: dex_proxy-deep-1
    ENVIRONMENT: dev
    USE_ATTESTATION: "false"
    TS_DEX_PATH: dexes/deepbook
  - PROCESS_NAME: dex_proxy-deep-2
    ENVIRONMENT: dev
    USE_ATTESTATION: "false"
    TS_DEX_PATH: dexes/deepbook
  - PROCESS_NAME: dex_proxy-deep-main
    ENVIRONMENT: prod
    USE_ATTESTATION: "false"
    TS_DEX_PATH: dexes/deepbook
  - PROCESS_NAME: dex_proxy-deep-main-2
    ENVIRONMENT: prod
    USE_ATTESTATION: "false"
    TS_DEX_PATH: dexes/deepbook
  - PROCESS_NAME: dex_proxy-hype-testnet
    ENVIRONMENT: dev
  - PROCESS_NAME: dex_proxy-hype-1
    ENVIRONMENT: prod
  - PROCESS_NAME: flip-lp-main
    ENVIRONMENT: prod
    DOCKERFILE: Dockerfile.fliplp
    VAULT_SECRET_FIELD: signing_key0


# Some applications are only containerised, and not enclaved. Supported keys:
# `CONTAINER_NAME`: (str) Determines name of the image that will be pushed to registry.
# `DOCKERFILE`:     (str) Relative (to repository root) path to the dockerfile for this container.
.containers: &containers
  - CONTAINER_NAME: dex-proxy-deepbook
    DOCKERFILE: Dockerfile.deepbook


variables:
  ENCLAVE_BUILD_IMAGE: registry.gitlab.com/auros/enclave-builder@sha256:e77aa40d986798480ff203b494c18e9697040804f4d633b789e610bfe4627736
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  # The following must actually be defined in the project CI/CD variables. They are explicitly included here, to
  # remind you.
  VAULT_SERVER_URL: https://vault.auros.be
  VAULT_AUTH_PATH: jwt-gitlab-com


default:
  image:
    name: $ENCLAVE_BUILD_IMAGE
    entrypoint: [""]
  services:
    # library/docker:24-dind
    - name: ${CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX}/docker@sha256:962ad28b5cddb82c7cadbf222a71c403bd97ef1814005624bd8a3697cbb58bba
      alias: docker
  before_script:
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
  retry: 1


.build on all commits and merge requests:
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH


build enclaves:
  stage: build
  extends:
    - .build on all commits and merge requests
  parallel:
    matrix: *enclaves
  script:
    - export CONTAINER_NAME=${PROCESS_NAME}
    - export CONFIG_REPO_URI=git@bitbucket.org:kenetic/config-${ENVIRONMENT}.git
    - echo ${SSH_PRIVATE_KEY_BASE64} | base64 -d -w 0 > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - git clone --depth 1 ${CONFIG_REPO_URI} _config
    - "[[ \"${VAULT_APPROLE_ID}\" ]] || { echo \"VAULT_APPROLE_ID is not defined\"; exit 1; }"
    - "[[ \"${VAULT_SECRET_ID}\" ]] || { echo \"VAULT_SECRET_ID is not defined\"; exit 1; }"
    - "[[ \"${VAULT_WALLET_NAME}\" ]] || { echo \"VAULT_WALLET_NAME is not defined\"; exit 1; }"
    - "[[ \"${VAULT_SECRET_FIELD}\" ]] && { ADDITIONAL_BUILD_ARGS=\"${ADDITIONAL_BUILD_ARGS} --build-arg VAULT_SECRET_FIELD=${VAULT_SECRET_FIELD}\"; }"
    - "[[ \"${KMS_KEY_ID}\" ]] || { echo \"KMS_KEY_ID is not defined\"; exit 1; }"
    - "[[ -f _config/${PROCESS_NAME}.json ]] || { echo \"No config found for ${PROCESS_NAME}\"; exit 1; }"
    - export CONTEXT_ID=$(jq -r '.enclave.cid | select(. != null)' _config/${PROCESS_NAME}.json)
    - rm -rf _config
    # Save the Gitlab job JWT token to file.
    - echo -En ${VAULT_ID_TOKEN} > jwt.json
    - /opt/auros/ImageBuilder.sh --enclave --sign
    - cp measurements.json measurements-${PROCESS_NAME}.json
    - cp signature.crt signature-${PROCESS_NAME}.crt
  variables:
    VAULT_AUTH_ROLE: gitlab-com-${CI_PROJECT_NAMESPACE}-${CI_PROJECT_NAME}-${PROCESS_NAME}-pipeline-enclave-build
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.auros.be
  secrets:
    VAULT_APPROLE_ID:
      vault: secure-builds/gitlab-com/${CI_PROJECT_PATH}/${PROCESS_NAME}-approle-id/value@kv
      token: ${VAULT_ID_TOKEN}
      file: false
    VAULT_SECRET_ID:
      vault: secure-builds/gitlab-com/${CI_PROJECT_PATH}/${PROCESS_NAME}-secret-id/value@kv
      token: ${VAULT_ID_TOKEN}
      file: false
    VAULT_WALLET_NAME:
      vault: secure-builds/gitlab-com/${CI_PROJECT_PATH}/${PROCESS_NAME}-wallet-name/value@kv
      token: ${VAULT_ID_TOKEN}
      file: false
    KMS_KEY_ID:
      vault: secure-builds/gitlab-com/${CI_PROJECT_PATH}/${PROCESS_NAME}-kms-key-id/value@kv
      token: ${VAULT_ID_TOKEN}
      file: false
  artifacts:
    paths:
      # PCR measurements; image PCRs must match the content of this file.
      - measurements-${PROCESS_NAME}.json
      # Image signing certificate. Key is discarded so it can never be reused.
      - signature-${PROCESS_NAME}.crt


# Some auxiliary applications in this repo need to be containerised, but not with an enclave userland.
build containers:
  stage: build
  extends:
    - .build on all commits and merge requests
  parallel:
    matrix: *containers
  script:
    - /opt/auros/ImageBuilder.sh


authorise enclave:
  stage: authorise
  parallel:
    matrix: *enclaves
  needs:
    - job: build enclaves
      artifacts: true
      optional: true
      parallel:
        matrix: *enclaves
  environment:
    name: ${ENVIRONMENT}
  rules:
    - if: '$ENVIRONMENT == "dev"'
      when: manual
    - if: '$ENVIRONMENT == "prod" && $CI_COMMIT_REF_PROTECTED == "true"'
      when: manual
  script:
    - "[[ \"${USE_ATTESTATION}\" =~ [Ff]alse ]] && { echo \"Attestation is not enabled for this build\"; exit 0; }"
    - "[[ \"${ENVIRONMENT}\" == \"prod\" && \"${CI_COMMIT_REF_PROTECTED}\" == \"false\" ]] && { echo \"This job is running for a production enclave in an unprotected branch; Vault will refuse your authorisation request. How did you even get here?\"; exit 1; }"
    - export CONFIG_REPO_URI=git@bitbucket.org:kenetic/config-${ENVIRONMENT}.git
    - echo ${SSH_PRIVATE_KEY_BASE64} | base64 -d -w 0 > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - git clone --depth 1 ${CONFIG_REPO_URI} _config
    - HOST_AFFINITY=$(jq -r '.app.host_affinity' _config/${PROCESS_NAME}.json)
    - "[[ \"${HOST_AFFINITY}\" == \"null\" ]] && { echo \"Cannot determine host affinity for authorisation; check that 'app.host_affinity' is set in config.json\"; exit 1; }"
    # Save the Gitlab job JWT token to file.
    - echo -En ${VAULT_ID_TOKEN} > jwt.json
    - enclave-authz --auth-mount ${VAULT_AUTH_PATH} -a legacy --jwt jwt.json -i ${HOST_AFFINITY} --pcr0 $(jq -r '.Measurements.PCR0' measurements-${PROCESS_NAME}.json) --pcr8 $(jq -r '.Measurements.PCR8' measurements-${PROCESS_NAME}.json) ${PROCESS_NAME}
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://vault.auros.be
  variables:
    # infra/terraform/environment/operational/sng/k8s
    # auth/jwt-gitlab-com/role
    VAULT_AUTH_ROLE: gitlab-com-${CI_PROJECT_NAMESPACE}-${CI_PROJECT_NAME}-${PROCESS_NAME}-pipeline-enclave-authz


# Don't allow the default scan job to run - we split it out into different jobs.
container_scanning:
  rules:
    - when: never


.container scanning:
  extends:
    - container_scanning
    - .build on all commits and merge requests
  before_script: []
  variables:
    CS_IMAGE: ${CI_REGISTRY_IMAGE}/${PROCESS_NAME}${CONTAINER_NAME}:${CI_COMMIT_SHA}
    DTRACK_PROJECT_NAME: ${PROCESS_NAME}${CONTAINER_NAME}
    DTRACK_PROJECT_VERSION: ${CI_COMMIT_SHA}


audit enclave userlands:
  extends:
    - .container scanning
  parallel:
    matrix: *enclaves
  needs:
    - job: build enclaves
      parallel:
        matrix: *enclaves


audit container userlands:
  extends:
    - .container scanning
  parallel:
    matrix: *containers
  needs:
    - job: build containers
      parallel:
        matrix: *containers

